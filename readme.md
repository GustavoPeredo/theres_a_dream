### What is this?

Well, it's many things but the coolest part is being able to very quickly implement new api endpoints
with type safety in the frontend and backend. What does that mean? To create a new api endpoint, you
simply create a new file under `backend/src/api` or use an already existing one. Then you define a
function like so:

```rust
#[make_endpoint::export_to("./bindings/sum.ts")]
pub struct QueryParams {
    a: i32,
    b: i32,
}

#[make_endpoint::make_endpoint]
pub fn sum(
    _token: String,
    params: QueryParams
) -> i32 {
    params.a + params.b
}
```

Now you can call this function from the frontend like so:

```typescript
import { sum } from './bindings/sum.ts';

const result = await sum({ a: 1, b: 2 });
```

And that's it! Everything is type safe and you can't mess up the parameters or the return type.

### How does it work? Part I

Well at an overview it's pretty messy, but in depth it's much cooler. Whenever a new function
is defined with `make_endpoint`, the macro sets up the endpoint; during build time files
under `backend/src/api` are read and parsed to generate the routes for `warp`.

To create the typescript bindings, there is a test under `backend/tests` that is not really a 
test but rather it takes advantage of the fact that the crate `rs-ts` can generate interfaces
for our types and creates functions that call the api endpoints. 

On top of all that, we can use the nix flake to build the frontend and backend, and deploy our project.

### How does it work? Part II


#### Backend

First there is the crate `jwt` there we find things related to, well, jwt. It was first made
because I thought it was possible to have libraries and others in a proc-macro crate, but it
is not. Eventually it should merge back to the main codebase under `backend`.

```toml
[dependencies]
jwt = { path = "../jwt" }
# There is still parts of my newbieness in the Cargo.toml file XD
```

Then there is the crate `make_endpoint` which is the most important part of the project. When
a function is defined with `make_endpoint` it sort of "decorates"
it, instead of just being a normal function it becomes a constructor for an endpoint, requiring only a path. [Check it out!](backend/make_endpoint/src/lib.rs)

Thus we come to `build.rs` and `templates/main.rs`. Using the `syn` crate, we parse the files under `backend/src/api` and generate in our `main.rs` the routes for our make_endpoint functions! It would be cool if we could generate the functions without
having to use `build.rs`, but it's completely understandable why it's not possible.

A few notes before rounding up the backend part: I made sure that the functions
receive first the `JWT` token, my idea is to eventually develop functions that will
leverage the token to allow or deny certain actions. Even though I'm not using it:

```rust
#[make_endpoint::make_endpoint]
pub fn sum(
    token: String,
    params: QueryParams
) -> i32 {
    params.a + params.b
}
```

#### Frontend

Since the backend will be used to generate the typescript bindings, we
still need to mess around with rust a bit more. First by making use of
the `rs-ts` crate, we can generate interfaces for our types, pretty
standard stuff; but we can't use it to generate our functions! So back
we go to creating more parsing code... this time to create functions
following this [template](backend/templates/function.ts):
    
```typescript
import callApi from './callApi';

export async function $function_name$(params: $arg_type$): Promise<$return_type$> {
    const response = await callApi($route$, params);
    return (await response.json()) as Promise<$return_type$>;
}
```

Most stuff should be pretty clear, we are changing the function name
to match the one in the backend, \$arg_type\$ is generated by `rs-ts`,
the return type and route are generated by our """test""".

The function callApi is a simple wrapper around fetch:
    
```typescript
export default async function callApi(endpoint: string, params: any): Promise<Response> {
    try {
        const token = localStorage.getItem('jwt');
        const response = await fetch(`http://localhost:3030/api/${endpoint}`, {
        /* Fetch stuff (and our params!) */
        });
        return response
    } catch (error) {
        /* Treat the error */
    }
}
```

This format should ensure that we use the minimum size of javascript
while also allowing splitting the functions into different files, if
the bundler decides to do so.

With that, simply copying and pasting the generated code into our
`frontend` folder is enough to use it in vue:

```typescript

<template>
  <div>
    <h2>Addition</h2>
    <input v-model.number="a" type="number" />
    <input v-model.number="b" type="number" />
    <p v-if="result">{{ result }}</p>
    <button @click="calc">Calculate</button>
  </div>
</template>

<script lang="ts">
import { sum } from '../bindings/sum';

export default {
  data() {
    return {
      a: 2,
      b: 2,
      result: 4
    };
  },
  methods: {
    async calc() {
      this.result = await sum({ a: this.a, b: this.b });
    },
  },
};
</script>

```

Since the frontend will be served
by the backend, it's actually pretty useful to use vue as a SPA.
It makes it simple in the future to parse data such as an user
id in the url, since our backend won't have dynamic routes.

#### Deployment

To top it all off, the deployment is done using nix. The flake.nix
has contructions for both the frontend, backend, devtools and creates
a deploy script that runs the backend. It needs to be updated to
create the bindings, but that's something for the future and not
really important now.

```nix
# THE POWER OF NIX
deploy = pkgs.writeScriptBin "deploy" ''
            WEB_APP_DIR=${self.packages.${system}.frontend} ${self.packages.${system}.backend}/bin/backend
            '';
```

### Conclusion

There is still a lot to do and improve, but now I'll take some time
off.